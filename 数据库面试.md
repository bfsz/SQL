## 1、事务的四大特性

**原子性**：事务所包含的一系列数据库操作要么全部成功执行，要么全部回滚 

**隔离性**：并发执行的事务之间不能相互影响 

**一致性**：事务的执行结果必须使数据库从一个一致性状态到另一个一致性状态 

**持久性**：事务一旦提交，对数据的改变就是永久的



## 2、数据库隔离级别

**脏读**：事务B读取事务A还没提交的数据

**不可重复读**：两次事务读的数据不一致

**幻读**：事务A修改了数据，事务B也修改了数据，这是在事务A看来，数据明明修改了，但是却不一样



## 3、索引的优缺点，何时使用，何时不能用

优点：提高查询速度、加速表和表之间的连接 

缺点：更新数据时效率低，因为要同时更新索引

对数据进行繁琐查询时建议使用，对数据进行繁琐修改时不建议使用。



## 4、索引的底层实现（B+树，为何不采用红黑树，B树）重点

|      树       |                             区别                             |
| :-----------: | :----------------------------------------------------------: |
|    红黑树     | 增加，删除，红黑树会进行频繁的调整，来保证红黑树的性质，浪费时间 |
| B树也就是B-树 | B树，查询性能不稳定，查询结果高度不致，每个结点保存指向真实数据的指针，相比B+树每一层每屋存储的元素更多，显得更高一点。 |
|     B+树      |      B+树相比较于另外两种树,显得更矮更宽，查询层次更浅       |

## 5、SQL优化

1、sql尽量使用索引，查询走索引

2、sql语句优化：

子查询变成 left join，子查询可以被更有效率的连接(Join)替代 

limit分布优化，利用ID定位，再分页

or条件优化，多个or条件可以使用union all对结果进行合并（结果可能重复）

不必要的排序

where代替having，having检索完所有记录，才进行过滤

避免嵌套查询

对多个字段进行等值查询时，联合索引

优化insert语句：一次插入多值； 

尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描； 

尽量避免在 where 子句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描 

很多时候用 exists 代替 in 是一个好的选择 



## 6、varchar和char的使用场景

varchar : 字符长度经常变的

char:	字符长度固定的



## 7、数据库三范式

1F:   属性不可分

2F：非主键属性完全依赖于主键属性

3F：非主键属性无传递依赖



## 8、关系型数据库和非关系型数据库区别

> 关系型数据库：

 	优点：

​		1、易理解：二维结构贴近逻辑世界一个概念，关系模型相对网状，层次等其他模型更容易理解

​		2、方便：使用SQL语言使得操作关系型数据库非常方便

​		3、易维护：丰富的完整性大大降低了数据冗余和数据不一致的概率

​		4、支持SQL:可用于复杂的查询

​		5、支持事务

​	缺点：

​		1、为了维护一致性所付出的巨大代价是其读写性能比较差

​		2、固定的表结构

​		3、不支持高并发读写

​		4、不支持海量数据的高效率读写

> 非关系型数据库：

​	优点：

​		1、使用键值对存储数据

​		2、分布式

​		3、无需经过sql层的解析，读写性很高

​		4、基于键值对，数据没有耦合性，容易扩展

​		5、存储数据格式：nosql [key,value]

​	缺点：

​		1、不支持事务

​		2、不提供sql支持



## 9、left join、right join 、inner join、cross join

例：A、B表

A left join B

选出A所有的记录，B中没有的以null代替

A right join B

选出B所有的记录，A中没有的以null代替

inner join

A\B所有记录都选出，没有的记录以null代替

corss join

笛卡儿积，A中每一条记录和B中每一条记录生成一条记录，A4条 、B4条  corss join后16条



## 10、有哪些锁、select时怎么加排它锁

乐观锁：自己实现，通过版本号

悲观锁：共享锁、多个事务、只能读不能写，加 lock in share mode

排它锁：一个事物只能写， for update

行锁：作用于数据行

表锁：作用于表



## 11、死锁怎么解决

找到进程号，kill 进程



## 12、一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。

 1、如果A表TID是自增长,并且是连续的,B表的ID为索引 

select * from a,b where a.tid = b.id and a.tid>500000 limit 200;  

2、如果A表的TID不是连续的,那么就需要使用覆盖索引.TID要么是主键,要么是辅助索引,B表ID也需要有索引。 select * from b , (select tid from a limit 50000,200) a where b.id = a .tid; 



## 13、**什么是存储过程？有哪些优缺点？** 

​	存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合。进一步地说，存储过程是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。存储过程具有以下特点： 

- 存储过程只在创建时进行编译，以后每次执行存储过程都不需再重新编译，而一般 SQL 语句每执行一次就编译一次，所以使用存储过程可提高数据库执行效率；
- 当SQL语句有变动时，可以只修改数据库中的存储过程而不必修改代码；
- 减少网络传输，在客户端调用一个存储过程当然比执行一串SQL传输的数据量要小；
- 通过存储过程能够使没有权限的用户在控制之下间接地存取数据库，从而确保数据的安全。



## 14、**drop、delete与truncate的区别** 

- Delete用来删除表的全部或者一部分数据行，执行delete之后，用户需要提交(commmit)或者回滚(rollback)来执行删除或者撤销删除， delete命令会触发这个表上所有的delete触发器；

- Truncate删除表中的所有数据，这个操作不能回滚，也不会触发这个表上的触发器，TRUNCATE比delete更快，占用的空间更小；

- Drop命令从数据库中删除表，所有的数据行，索引和权限也会被删除，所有的DML触发器也不会被触发，这个命令也不能回滚。

  因此，在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。



## 15、**什么叫视图？游标是什么？** 

​	视图是一种虚拟的表，通常是有一个表或者多个表的行或列的子集，具有和物理表相同的功能，可以对视图进行增，删，改，查等操作。特别地，对视图的修改不影响基本表。相比多表查询，它使得我们获取数据更容易。 

​	游标是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。 



## 16、**什么是触发器？** 

​	触发器是与表相关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合。触发器的这种特性可以协助应用在数据库端确保数据库的完整性。 



### 17、DDL、DML、DCL

**DDL（data definition language）数据库定义语言：**

​	其实就是们在创建表的时候用到的一些sql，比如说：CREATE、ALTER、DROP等。DDL主要是用在定义或改变表的结构，数据类型，表之间的链接和约束等初始化工作上。

**DML（data manipulation language）数据操纵语言：**

​	就是我们最经常用到的 SELECT、UPDATE、INSERT、DELETE。 主要用来对数据库的数据进行一些操作。

**DCL(Data Control Language)——数据控制语言：**

​	用来授予或回收访问数据库的某种特权,并控制数据库操纵事务发生的时间及效果,对数据库实行监视等。 

COMMIT - save work done 提交

SAVEPOINT - identify a point in a transaction to which you can later roll back 保存点

ROLLBACK - restore database to original since the last COMMIT 回滚